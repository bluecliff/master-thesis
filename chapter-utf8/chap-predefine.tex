%%第二章，预备知识
\chapter{预备知识}
\label{chap:predefine}

以BWT为代表的自索引算法近年来在序列比对领域多有出现，例如前文中提到的Bowtie，BWA等。本文提出的序列比对算法使用的也是一种
自索引算法：压缩后缀数组(CSA)\cite{grossi2005compressed}。同BWT相比，CSA的模式查询速度更快，应用于序列比对，相应的比对速
度也会更快，提高整个比对的效率。相应的，在使用CSA之前有必要对CSA的一些概念进行一些简单的叙述，此外序列比对领域的一些基本
概念也会在本章中解释。

\section{压缩后缀数组和模式匹配}

\subsection{后缀数组和压缩后缀数组简介}
压缩后缀数组(CSA)是由Grossi和Vitter\cite{grossi2005compressed}最早提出的第一种实现全文索引的压缩索引数据结构，是对后缀数组(SA)
\cite{manber1993suffix}占用空间过大的改进，并且实现了自索引特性。

设长为$n$的文本序列$T$，字符集为$\Sigma$，本文中将假设$T$有一个特殊的结尾符号$\$$，$\$$不在$\Sigma$中并且字典序小于$\Sigma$
中的所有符号。假设$T$存储在一个数组$T[0\ldots n-1]$中。对任何的整数$i$，假设
\begin{itemize}
    \item $T[i]$为$T$中从左往右0开始的第$i$个字符;
    \item $T_i$为$T$的第$i$个后缀，即$T_i=T[i]T[i+1]\ldots T[n-1]$。
\end{itemize}

$Ｔ$的后缀数组$SA[0\ldots n-1]$定义为
$T$的$n$个后缀按字典序排序后的序列，由$\{0,1,\ldots, n-1\}$的一个排列构成，满足$T_{SA[0]}<T_{SA[1]}<\ldots<T_{SA[n-1]}$。即$SA[i]$
表示$T$的$n$个后缀中第$i$小的后缀的开始位置。如表\ref{tab:tabsuffix}所示。后缀数组占用空间$n\log n$，给定文本$T$和其后缀数组
$SA[0\ldots n-1]$，$T$中的任何模式$P$可以在$O(|p|\log n+occ)$时间复杂度内求出其出现位置\cite{manber1993suffix}，并且不需要
读原文本$T$。其中$occ$是模式的出现次数。

对于任意的整数$i \in [0\ldots n-1]$，定义$SA^{-1}[i]=j$使得$SA[j]=i$，很明显$SA^{-1}[i]$为$T_i$在$T$的所有后缀中的排名，即
$T$的后缀中比$T_i$小的后缀的数量。

\begin{table}[htbp]
    \caption{$acaaccg\$$的后缀数组和$\Phi$数组}
    \label{tab:tabsuffix}
    \centering
    \begin{tabular}{lllllll}
        \hline\\
        $i$&$T[i]$&$T_i$&$SA[i]$&$T_{SA[i]}$&$\Phi[i]$&$T[SA[i]]$\\
        \hline\\
        0&a&acaaccg\$&7&\$&2&\$\\
        1&c&caaccg\$&2&aaccg\$&3&a\\
        2&a&aaccg\$&0&acaaccg\$&4&a\\
        3&a&accg\$&3&accg\$&5&a\\
        4&c&ccg\$&1&caaccg\$&1&c\\
        5&c&cg\$&4&ccg\$&6&c\\
        6&g&g\$&5&cg\$&7&c\\
        7&a&\$&6&g\$&0&g\\
        \hline
    \end{tabular}
\end{table}

\begin{equation}\label{eq:phi}
    \Phi [i] = j \qquad if\ SA[j] = (SA[i]+1)\mod n \cite{huo2014practical}
\end{equation}

序列 $T$ 的压缩后缀数组(Compressed Suffix Array, CSA)是对后缀数组(SA)空间复杂度过大的一个改进。其本身也是一个包含$n$个
整数与后缀数组$SA$大小相同且由$SA$的近邻函数变换而来的数组$\Phi$。近邻函数定义如\ref{eq:phi}，由于$T[n-1]=\$$，所以
$\Phi[0]=SA^{-1}[0]$。另一个角度来看，若后缀$T_k$在$T$的后缀中排名为$i$，则$\Phi[i]$为后缀$T_{k+1}$在$T$的后缀中的排名。
同时，可以看到$SA^{-1}[1]=SA^{-1}[SA[SA^{-1}[0]+1]=\Phi[\Phi[SA[SA^{-1}[0]]]]=\Phi[\Phi[0]]$，同理可以得到$SA^{-1}[2]=\Phi[\Phi[\Phi[0]]]$。
以此类推，即可根据$\Phi[0\ldots n-1]$迭代求出$SA^{-1}[0\ldots n-1]$，由$SA^{-1}[0\ldots n-1]$可快速求出$SA[0\ldots n-1]$。
由此可得出，从后缀数组$SA[0\ldots n-1]$到数组$\Phi[0\ldots n-1]$的变换是可逆的。

$\Phi[0\ldots n-1]$包含$n$个整数，显示存储时，也需要$n\lceil \log n \rceil$位的存储空间，同后缀数组$SA$相同。然而，观察表\ref{tab:tabsuffix}
可以发现$\Sigma[1\ldots n-1]$可以分解为$|\Sigma|$个严格递增的序列，这使得压缩后缀数组可以用简明数据结构存储。而$\Sigma[1\ldots n-1]$
的递增属性则是基于以下引理。

\begin{lem}\label{ref:lem1}
对于任意的整数$i<j$,若$T[SA[i]]=T[SA[j]]$，则$\Phi[i]<\Phi[j]$。
\end{lem}

\begin{proof}
    当$i<j$时，则$T_{SA[i]}<T_{SA[j]}$一定成立，反之亦然。这等价于当$T[SA[i]]=T[SA[j]]$时，$T_{SA[i]+1}<T_{SA[j]+1}$，即$T_{SA[\phi[i]]}<T_{SA[\Phi[j]]}$，
    所以可以得到$\Phi[i]<\Phi[j]$。即引理\ref{ref:lem1}成立。
\end{proof}

对任意一个$\Sigma$中的字符$c$，定义$\alpha(c)$为$T$的后缀中首字符小于$c$的后缀的数目，定义$\beta(c)$为$T$的后缀中首字符为
$c$的后缀的数目。则有以下结论：

\begin{cor}\label{cor1}
对于$\Sigma$中的任意一个字符$c$，$\Phi[\alpha(c)], \Phi[\alpha(c)+1] \ldots \Phi[\alpha(c)+\beta(c)− 1]$是一个严格递增序列。
\end{cor}

\begin{proof}
    对于任意的字符$c$，$T[SA[\alpha(c)]]=T[SA[\alpha(c)+1]]=\ldots =T[SA[\alpha(c)+\beta(c)-1]]=c$，由引理\ref{ref:lem1}可知，
    $\Phi$在$\Phi[\alpha(c)\ldots \alpha(c)+\beta(c)-1]$上严格递增。
\end{proof}

根据以上结论，$\Phi$可以划分为$|\Sigma|$个递增序列，Grossi和Vitter\cite{grossi2005compressed}提出了一种压缩模式来存储$\Phi$，
使得可以在$O(n(H_0+1))$位的空间内存储$\Phi$数组，其中$H_0 \leq \log |\Sigma|$，是文本$T$的0阶经验熵。这种存储模式就是下文中
叙述的简明数据结构。

\subsection{简明数据结构}

简明数据结构(Succint Data Structure)是对整数序列进行简明编码，达到压缩存储的效果并实现常数时间解码的数据结构。本节中将以Vitter
原始论文中的Rice编码为例阐述简明数据结构的存储原理。实际上，除了Rice编码，简明数据结构还可以使用很多编码形式，如$\Delta-\sigma$
编码等。

设有$s$个升序的整数，每一个整数有$w$位，$s<2^w$。简明数据结构的原理是把这$s$个整数分为两部分，分别存储在两个表$Q,R$里。
取出每个整数的前$z=\lfloor \log s\rfloor $位组成一个新的整数，设为$q_i$，明显有$0 \leq q_h \leq q_{h+1} < s$，其中$1 \leq h < s$。
设各个整数中去除前$z$位后剩下的部分组成的整数为$r_1,r_2,\cdots r_s$。

由于$q_1 \leq q_2 \leq \cdots \leq q_s$，所以采用一元编码（unary repesentation）表示$q_i$。对于任意的整数$i \geq 0$，其一元编码为
$0^i1$，即$i$个$0$后紧随一个$1$。在此构建$Q$表采用一元编码表示：$q_1,q_2-q_1,\cdots ,q_s-q_{s-1}$。由此，表$Q$是一个二进制表。加上
辅助数据结构$select$操作，可以在常数时间内获得表$Q$二进制串中第$h$个$1$出现的位置。为获取$q_h$，只需调用$select(h)$获得第$h$个$1$
出现的位置$j$，再通过$j-h$计算出二进制串中前$j$位中$0$的个数，很明显，串中$0$的个数$j-h$即为$q_h$。

表$Q$由两部分组成，表示$q_i$的二进制串和辅助数据结构。总共有$s$个数，所以二进制串中至少有$s$个$1$；$q_i$中最大的数为$2^z$，所以最多
有$2^z$个$0$，所以二进制串的内存空间为$s+2^z \leq 2s$位。而支持$select$操作的辅助数据结构的空间复杂度是$O(s/\log \log s)$ 位，所以$Q$表总的
空间复杂度是$2s+O(s/\log \log n)$。查询时间为常数时间。

对于$R$表，可以简单的当作普通数组存储即可，总共需要$s(w-\lfloor \log s \rfloor)$位，查询时间也为常数时间。

最后，为查询升序整数序列中任意一个整数$s_h$，只需查询$Q$表和$R$表分别获取$q_h$和$r_h$，而后返回$q_h \cdot 2^{w-z}+r_h$即为所查询
的$s_h$。时间复杂度为常数时间。

综上所述，可得以下结论：
\begin{cor}\label{cor2}
对于$s$个升序的整数组成的序列，设每一个整数最多$w$位且$s<2^w$，可以把这$s$个整数存储在最多$s(2+w-\lfloor \log s \rfloor)+O(s/\log \log s)$位
的空间内，且查询任意整数的时间复杂度为$O(1)$。
\end{cor}

\subsection{rank\&select操作}

根据上一小节的论述，简明数据结构实现的基础是rank\&select操作，本节即详细介绍这两个操作的实现方法。Jacobson在论文\cite{jacobson1989space}
中阐述了这两种操作的经典采样分割实现方法。由于经典方法存在空间复杂度较低的问题，本文采用了更高效的RRR方法实现rank\&select操作。

RRR方式是由R.Raman，V.Ramna以及S.Srinivasa Rao等人于2002年提出的一种静态的字典结构\cite{raman2002succinct}。通过这种结构可以
实现对01二元序列的常数时间的rank\&select操作，并且采用同一方法可扩展到对多符号序列的常数时间的rank\&select操作。在二元01序
列上，RRR方法实现rank操作只需要$nH_0 + o(n)$位的空间，而常用的Jacobson的rank\&select方法则需要$n + O(n\log\log n/\log n)$位
的空间\cite{jacobson1989space}。可以看到在01序列中，如果0和1的几率相等时，二者的空间占用相差不大，而若0和1出现的几率并不相
等，其中一个出现的几率远大于另一个时，RRR方法的空间占用将小于n比特。而在压缩后缀数组$\Phi[0\ldots n-1]$的简明存储中，需要维
持一个由01序列构成的采样点的字典结构，该字典需要实现rank\&select操作，且字典中的0远多于1，在这一应用场景中，采用RRR方法要优
于Jacobson的方法。

RRR方法和Jacobson的方法在目录结构上类似，都采用了分块的方法和两层目录结构。具体做法是首先把长为$n$的二元串$B$分长为
$s = \log n^2$的大块$S_1, S_2\ldots S_{n/s}$。之后每一个大块再分成长为$b = \log {n/2}$的小块$B_i(j)$。这两种划分方
法在RRR中和Jacobson的方法是一致的，所不同的是之后的处理。对于每一个小块$B_i(j)$，在Jacobson的方法中是显式直接存储的，
而在RRR方法中则采用了一个$(c, o)$对替代$B_i(j)$，其中$c$表示$B_i(j)$这个小块中的1的个数，即这个小块的类别，而$o$表示$B_i(j)$
在所有的有$c$个1的长为$b$位的证数中的名次。显然，对于第$c$类，总共有$\binom{b}{c}$个。而$c$的最大值为b，所以一个$(c, o)$对
需要的存储空间是$\log{c + 1} + \log{\binom{c}{b}}$位。从这里可以看出，相对于原来的$b$位的原始串，采用一个$(c, o)$对替代后
，所需空间是随原始串中1的个数变化的，1的个数越少（即$c$越小），所需要的存储空间也会相应的变小，而就整体而言，一个$(c, o)$对
所占的空间也是小于$b$位的。这就是RRR方法的优势所在。对于每一类$c$中的每一个$(c, o)$对，都可以预先处理得到这个$(c, o)$对对应
的长为$b$的01串的每一位的$rank$值，并保存为$G_c$表，总共需要$b\log(c + 1)$位的空间。所有的$G_c$表组合起来就构成了我们预处理
得到的表$G$，总共需要$\sum_{c=0}^b {b\log (c+1)\binom{c}{b}=O(\sqrt{n}poly \log n)}$位的空间。

通过上面叙述的方法，可以把每
一个小块$B_i(j)$变换成一个$(c, o)$对，表示为$D_i(j)$，并且$D_i(j)$总共需要$\log(c + 1) + \log\binom{c}{b}$位的空间，累加
所有的小块对应的$(c, o)$对所需要的空间，前面一项累加后为$O(\log\log n)$位，后面一项累加起来为$nH_0$位。把所有的变长的
$D_i(j)$连接起来构成一个单独的表，即$D$表，所需空间为$nH_0 + O(\log\log n)$位。

对于每一个大块$S_i$ ,对应存储一个指针$P_i$指向这个大块的第一个小块对应的$(c, o)$对在$D$表中的位置，即$P_i = D_i(0)$，并
且指针$R_i$存储这个大块对应的第一位的$rank$值，即$R_i = rank((i-1)*s)$。$P$表和$R$表总共需要的空间是$O(n/\log n)$位。同
样的，对应每一个属于大块$S_i$的小块$B_i(j)$，也存储一个指向其$(c, o)$对在$D$表中的位置的指针$L_i(j)$，只是$L_i(j)$是该
位置相对于所在大块位置的相对位置，即$L_i(j) = D_i(j)-P_i$。类似的，保存每一个小块$B_i(j)$的第一位的$rank$值$Q_i(j)$，
当然也是相对于所在大块的$rank$值，即$Q_i(j) = rank((i-1)*s) + (j-1)*b) - R_i$。由于这些相对量的最大值都是$\log n$，所
以$L$表和$Q$表总共需要$O(n \log\log n/\log n)$位的空间。

在求解任意的$rank(p)$时，首先计算第$p$位对应的大块的编号$i = p/s$，
以及小块编号$j = (p -(i -1)*s)/b$，之后，加上所在的大块对应的$rank$值$R_i$和小块对应的相对$rank$值$Q_i(j)$。再根据$P_i$和
$L_i(j)$的值可得到这个小块对应的$(c, o)$对的值$D_i(j)$，通过访问$D$表的$D_i(j)$位置，即可得到第$p$位所在小块的每一位的$rank$
值，加上前面得到的相对$rank$值即可得到最终的$rank$值。

上面所述即为RRR方法的原理，总共需要保存$D，P，R，L，Q$五个表，总的空间需求是$nH_0 + O(n \log\log n/\log n)$位，可以在常数
时间内实现$rank$操作。

RRR方法的$select$操作的实现是基于$rank$的实现的，查找$rank[j]=i$，并且$rank[j-1]=i-1$，则有$select[i]=j$。所以，只需在一直
$rank$时，进行简单的二分查找即可实现求解$select$操作，且不需要任何的额外的辅助空间，时间复杂度是$rank$操作时间复杂度的
$\log n$倍。该方法的优点是实现简单，不需要额外的空间，但却并没有很好的利用RRR方法的性质。从上一小节的叙述中可知，为了实现
RRR的$rank$操作，特意存储了两个目录表，$R$表和$Q$表，其中$R$表是第一级目录，即大块儿的初始位置的$rank$值，而$Q$表是第二级目
录，即各个小块儿的初始位置相对所在大块儿的起始位置的相对$rank$值。利用这一性质，$select$操作可以更高效的完成，原理依然是二
分搜索，但无需对整个序列的$rank$进行二分操作，而是在两层目录上分别进行二分搜索，逐层的缩小搜索的范围，最后实现$select$操作。
具体的计算$select[j]$的算法过程如下：

\begin{algo}
    \qquad \\

    1.首先搜索$R$表，得到一个位置$i$，使得$R[i]<j<R[i+1]$，即可确定$i*s<select[j]<(i+1)*s$。
    
    2.再搜索$Q$表中的$Q[i*s,i*s+1\ldots (i+1)*s]$得到$k$使得$R[i]+Q[k]<j<R[i]+Q[k+1]$ ，即可确定$k*b<j<(k+1)*b$。
    
    3.有了前两部的范围，实际上即得到了对应的第三次查询的需要的大块儿的编号$i$和小块儿的编号$k$，查询$P[i]$和$L[j]$即
    得到了对应的$(c,o)$对在$D$表中的位置，接下来查询$D$表即可得到该$(c,o)$对对应的局部$rank$值。
    
    4.线性查询第3步中得到的$D$表中的$rank$序列，使得$rank[m]=j-R[i]-Q[k]$，则$select[j]=i*s+k*b+m$，即为最终查询结果。
\end{algo}

上述的$select$方法基于二分实现，时间复杂度是三次查询时间复杂度之和，即$\log{n/s}+\log{s/b}+\Theta(b)$。

\section{序列比对}

\subsection{DNA序列格式}

在DNA序列分析领域，DNA数据一般都来自国际知名的几大DNA数据库，如GenBanki，EMBL，DDBJ等。不同的测序方法，通常得到的序列数据也会
有一些差异。对此，为方便后续处理，生物信息学定义了一些通用的序列存储格式，如Fasta，Fastq等。通常Illumina测序数据都是Fastq格式，
所以本文中实现的软件CSAA也以Fastq作为标准输入格式。

Fastq格式是DNA序列格式中常见的一种，Fastq格式的序列一般都包含有四行，第一行由'@'开始，后面跟着序列的描述信息，这点跟Fasta格式
是一样的。第二行是序列的字符表示。第三行由'+'开始，后面也可以跟着序列的描述信息，和第一行信息相同，通常可以省略。第四行是第二行序列的质量评价
（quality values，是测序的质量评价），字符数跟第二行的序列是相等的。下面是Fastq格式序列的一个序列示例。

\begin{verbatim}
@HWUSI-EAS100R:6:73:941:1973#0/1
GATTTGGGGTTCAAAGCAGTATRRRGYKKKMSTCAAATAGTAAATCCATTTGTTCAACT
+HWUSI-EAS100R:6:73:941:1973#0/1
!''*((((***+))%%%++)(%%%%).1***-+*''))**55CCF>>>>>>CCCCCCC6
\end{verbatim}

Illumina测序仪是按照荧光信号来判断所测序的碱基是哪一种的，例如红黄蓝绿分别对应ATCG，但对每个结果都是有一定的误差的。最初sanger
中心用Phred quality score来衡量该read中每个碱基的质量，既$Q=-10\lg P$ ，其中$P$代表该碱基被测序错误的概率，如果该碱基测序
出错的概率为$0.001$，则$Q=30$，30+33=63，63对应的ASCii码为“？”，则在第四行中该碱基对应的质量分数代表值即为“？”。
一般地，碱基质量从0-40，既ASCii码为从 “！”（0+33）到“I”(40+33）。这上是sanger中心采用记录read测序质量的方法，Illumina
没有完全依照sanger中心的方法来定义测序质量，而是把$P$换成了$P/(1-P)$，其他完全按照sanger的定义来做。可以看出当测序质量
很高的情况下两种形式几乎没区别，但低质量的碱基则有区别了。

在Fastq格式中还可能出现其他一些核苷酸符号，具体含义如表\ref{tab:tabatcg}所述。

\begin{table}[htbp]
    \caption{Fastq格式支持的核苷酸符号}
    \label{tab:tabatcg}
    \centering
    \begin{tabular}{ll}
        \hline\\
        核苷酸代码&意义\\
        \hline\\
        A & Adenosine \\
        C & Cytosine \\
        G & Guanine \\
        T & Thymidine \\
        U & Uracil \\
        R & G A (puRine) \\
        Y & T C (pYrimidine) \\
        K & G T (Ketone) \\
        M & A C (aMino group) \\
        S & G C (Strong interaction)\\
        W & A T (Weak interaction) \\
        B & G T C (not A) (B comes after A)\\
        D & G A T (not C) (D comes after C) \\
        H & A C T (not G) (H comes after G) \\
        V & G C A (not T, not U) (V comes after U)\\
        N & A G C T (aNy)\\
        X & masked \\
        - & gap of indeterminate length
    \end{tabular}
\end{table}

DNA序列的标准保存格式是Fastq等格式，同样的，对序列比对的输出格式，也有一个约定的标准数据格式：SAM格式。SAM的全称是
sequence alignment/map format，一般是文本形式的，也可以存为二进制形式文件，即BAM格式。SAM由头文件和map结果组成，头
文件由一行行以“@”起始的注释构成。而map结果是类似下面的文本：

\begin{verbatim}
C12FP66670 0    chr1  12805 1 42M4I5M * 0 0 TTGGATGCCCCTC...
C12FP30032 272  chr1  13494 1 51M     * 0 0 ACTGCCTGGCGCT...
\end{verbatim}

SAM文件中每个read只占一行，被tab分成了很多列，一共有12列，分别记录了：read名称，SAM标记，chromosome名称，5′端起始
位置，MAPQ（mapping quality，描述比对的质量，数字越大，特异性越高)，CIGAR字串(记录插入，删除，错配信息)，mate名称(
记录mate pair信息)，mate的位置，模板的长度，read序列，read质量，程序用标记。

本文中重点关注的是第三列，chrome名称，以及第四列，起始位置。通常作为参考序列的基因组是由多条染色体构成的，比对程序
需要得到read在哪一条染色体上，以及在改染色体上的位置，即5'端起始位置。

\subsection{单端测序和双端测序}
目前的测序方法中，如Solid，都有单端测序(Single-read)和双端测序(Paired end)之分。二者再测序方法上不同，得到的测序数据也有一些
差异。主要区别在于文库的建立上。

无论是单端测序还是双端测序，第一步都是对DNA分子进行切割，这是通过切割酶来实现的。切割后，大DNA分子被切割成长为300bp左右的短
序列(fragments)。测序第二步是增值，通过对这些短序列进行复制，增值，提高DNA分子数量。第三部是加入引物，开始测序。单端测序时
只在DNA短序列分子的一端加上引物，然后依次读取核苷酸，直到读完一个read。通常一个read长为80到1000bp，读取核苷酸时，因为越往后
读取错误率越高，所以一般read序列也是越往后，可靠性越低。双端测序时，会在DNA短序列两端都加上引物，然后分别读取核苷酸。所以，
双端测序得到的是一个DNA短序列分子的两个read，这两个read读取的是DNA链的两个不同的链，并且因为只读取两端的前100bp左右的核苷酸，
所以，这两个read序列并不一定重合，二者之间有一定的距离(distance)，distance的长度为短序列(fragment)的长度减去两个短读序列的
长度之和。反映到在参考DNA序列上，distance为两个序列映射位置之差的绝对值。

\section{本章小结}
本章分为两个部分，对本文用到的一些先验知识做了一些简述。第一部分简述了本文要用到的索引算法：压缩后缀数组。描述了其基本特性，
以及可压缩性，接着对简明数据结构做了一些简单介绍，重点是使用到的rank\&select结构：RRR结构。第二部分是对生物信息学领域序列
比对的一些基本概念的解释。包括DNA序列数据格式和单端测序，双端测序的概念。
